有如下一组数据，现任意给出一个数字，写程序找出所给数字在这组数据中第几个位置，若无法找到则输出为 0。

```text
1 4 6 7 8 9 12 14 15 16 17 20 25 32 36 48 49 50
```

上述问题非常简单，对于待查找的数字，只需要使用循环逐一查看是否和它相等，若循环结束后都还没有找到与其相等的数字，则说明带查找数字在数据中不存在。我们可以写出如下程序。

```cpp
int find(int num[], int len, int target) {
    for(int i = 0; i < len; i++) {
        if(num[i] == target) {
            return i+1;
        }
    }
    return 0;
}
```

仔细观察会发现题目中所给的数据是升序排列的，我们所写的程序虽然可以找到目标在数据中的位置，但却没有利用上数据已经排好序的优点。

回忆一下上小学时查《新华字典》的场景，我们从索引部分知道所查文字在第 456 页，此时并不是从第 1 页开始一页一页翻到第 456 页，而是直接翻到字典的中间位置，如果页码比 456 要大则向前翻大概一半，否则向后翻大概一半的样子，重复这个过程很快就能翻到第 456 页。

可以发现在翻阅字典的过程中，左手和右手限定了翻阅的范围，每一次只会在这个范围进行翻阅，并且整个过程左手都一定在右手的左边。查阅字典的过程与「二分查找」极为相似，据此我们可以写出二分查找的程序。

```cpp
int find(int num[], int len, int target) {
    // left 和 right 限定查找范围
    int left = 0, right = len-1;
    // 若left > right 则没有范围，程序应该结束
    while(left <= right) {
        // 每次跳到给定范围的中间位置
        int mid = (left + right) / 2;
        if (num[mid] == target) {
            return mid+1;
        } else if(num[mid] > target) {
            // 比目标值要大说明应该应该向左边缩小范围
            right = mid -1;
        } else if(num[mid] < target>) {
            // 比目标值小，说明应该向右边缩小范围
            left = mid + 1;
        }
    }
    // 若循环结束还没有返回，则说明目标值不存在于数据中
    return 0;
}
```

因为二分查找每次都舍弃了一半的数据，所以也有人将其称为「折半查找」。在绝大多数情况下二分查找都要比顺序查找更加优化，尤其在数据量非常大的时候表现的尤为明显。