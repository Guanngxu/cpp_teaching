假设你现在是一名体育老师，一群孩子冲向操场等待着你给他们上课，在孩子们心中体育课是用来玩耍的，为了能给自己留出更多的时间自由活动，孩子们早早的就站成一排，急切的等待你点名后的一声「解散」令下。然而孩子们站的队列却是杂乱无章，就像下图展示的样子一样。

![待排序数组](https://raw.githubusercontent.com/Guanngxu/cpp_teaching/main/img/select_sort/1.png)

作为体育老师的你现在需要让孩子们站成整齐的一排，毕竟还有校领导和其它老师看着的，如果体育老师连队列都组织不整齐的话，那不是分分钟就被会被解雇吗？那么现在问题来了，怎么才能让散乱的队列变成整齐的队列？

聪明的你很快就想到了从孩子们里面挑个头最矮的，让个头最矮的同学站到一个新的队列去。然后再从剩下的同学里面挑个头最矮的（所有同学中个头第二矮），让这个同学站到新的队列后面......重复这个过程直到最后一个同学，整个队伍就能排好顺序。

![查找最小值](https://raw.githubusercontent.com/Guanngxu/cpp_teaching/main/img/select_sort/2.png)

可以发现比较重要的过程是找个头最矮同学，我们先实现一个程序，这个程序可以把第一个个头最矮的同学找到。

```cpp
void select_sort(int a[], int len)
{
    // 查找最小值
    int min = 999;
    for(int i = 0; i < len; i++) {
        if(min > a[i]){
            min = a[i];
        }
    }
    cout<<min<<endl;
}
```

输入如下测试数据，可以得到该组数据的最小值为 150。

```text
7
180 170 176 160 155 150 160
```

到现在我们仅仅只是排好了一个同学，还有剩下的 n-1 个同学没有排好。对剩下同学的排序方法和第一个同学一摸一样，所以我们只需要将找最小值的过程重复 n 次即可。

```cpp
void select_sort(int a[], int len)
{
    // 查找 n 次最小值
    for(int j = 0; j < len; j++){
        // min 用于记录最小值
        int min = 999;
        for(int i = 0; i < len; i++) {
            if(min > a[i]){
                min = a[i];
            }
        }
        cout<<min<<endl;
    }
}
```

运行上述程序发现每次输出的都是最小值，原因在于我们每次找到最小值之后并没有把它从数组中踢出去，致使数组中的最小值一直都没有改变。因此我们每次确定好最小值后，需要将它给踢出去。

```cpp
void select_sort(int a[], int len)
{
    for(int j = 0; j < len; j++){
        int min = 999;
        // 记录最小值的位置
        int pos = 0;
        for(int i = 0; i < len; i++) {
            if(min > a[i]){
                min = a[i];
                pos = i;
            }
        }
        // 将该位置设为一个比较大的值，即将其踢出去
        a[pos] = 999;
        cout<<min<<endl;
    }
}
```

至此已经能比较好的将其排序输出了，但仔细想想会发现我们每次找最小值都用了 n 次循环，而实际上我们找第一个最小值需要 n 次，找第二个需要 n-1 次，找第三个只需要 n-2 次......很明显是做了一些重复性工作的。

除了找最小值时做了重复工作外，该程序还有一个问题是无法直接拿到其它地方使用，比如输入数据中有比 999 还要大的数，那么程序将无法正常给出结果。另外我们更希望该程序运行结束后，原数组就直接排好序了，这样方便后续的程序处理。

那么可以想到，第一次找到最小值后就和数组中第一个元素进行交换，第二次找到最小值后就和第二个最小值进行交换，第三次......这样操作 n 次之后就可以得到一个被排好序的数组，如下图所示。

![选择排序过程](https://raw.githubusercontent.com/Guanngxu/cpp_teaching/main/img/select_sort/3.png)

```cpp
void select_sort(int a[], int len)
{
    for(int j = 0; j < len; j++){
        // min 记录最小值，假设当前所看的元素就是最小值
        int min = a[j];
        // 记录最小值的位置
        int pos = j;
        // 前面 j-1 个位置已经排好了
        // 需要对比从 j+1 位置开始到最后一个
        for(int i = j+1; i < len; i++) {
            if(min > a[i]){
                min = a[i];
                pos = i;
            }
        }
        // 找到最小值后将其和第 j 个元素进行交换
        // 即第一次和第一个位置交换，第二次......
        int c = a[j];
        a[j] = a[pos];
        a[pos] = c;
    }
}
```

至此我们已经完成了一个相对通用的选择排序函数，在这里我要提示一下`int pos = j`不可以更改为`int pos = 0`，因为如果刚好遇到某次 min 一上来就记录的是最小值，那么内部`for`循环中的`if`条件分之将不会被执行，那么就会导致「最小值」和所记录的「最小值位置」不匹配。整个函数的过程可以用下面的动图形象的展示。

![选择排序动图](https://raw.githubusercontent.com/Guanngxu/cpp_teaching/main/img/select_sort/select_sort.gif)

下面我们给出选择排序的最终代码。

```cpp
void select_sort(int a[], int len)
{
    for(int j = 0; j < len; j++){
        int pos = j;
        for(int i = j+1; i < len; i++) {
            if(a[i] < a[pos]){
                pos = i;
            }
        }
        int c = a[j];
        a[j] = a[pos];
        a[pos] = c;
    }
}
```