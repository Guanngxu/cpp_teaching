我们国家每十年进行一次人口普查工作，每个地方的政府负责当地的人口普查工作。假设你是 A 村的村长，现在你需要统计本村 m 个不同年龄以上的人口数量，在此之前你的助理已经把本村每个人的年龄都汇总到数据表里面了，由于是挨家挨户进行填报的，所以这张表并没有提前按照年龄大小排好序。比如如下数据，表示本村共有 5 个人，第二行是这 5 个人的年龄，第一行第 2 个数表示 m，即需要统计多少个年龄以上的人口数量，第三行第四行共两个数，分别对应需要统计 42 岁以上的人数和 26 岁以上的人数。

```text
5 2
4 42 40 26 46
42
26
```

上面这个问题非常好解决，每个年龄逐一去比较即可，非常简单我们就能写出如下程序。

```cpp
int count(int person[], int len, int ages[], int m) {
    // person 表示年龄表，len 为本村人口数量
    // ages 表示需要统计的年龄，m 表示统计年龄的个数
    for(int i = 0; i < m; i++) {
        int total = 0;
        for(int j = 0; j < len; j++) {
            if(person[j] >= ages[i]) {
                total++;
            }
        }
        cout<<total<<endl;
    }
}
```

因为只有一个村的人口，数据量相对来说还比较小，上面的办法相对来说还比较适用。但是如果是一个国家的人口呢？我们国家总共有 14 亿多的人口，如果再一个一个数可能连吃饭的时间都没了。我们知道每一项数据在数据表中都占了一个编号，如果数据是已经排好顺序的，那么我们只需要找到对应统计年龄的编号，就能知道比该年龄大的人数了。而找对应年龄的编号也很方便，我们一个一个查看即可。

再深入想一想会发现，数据已经排好序了，现在要做的工作不就是在已经排好序的列表里面查找目标值吗？这不就是我们的二分查找吗？所以可以写出如下的程序。

```cpp
int count(int person[], int len, int ages[], int m) {
    // 对数组进行排序
    sort(person, person+len);
    for(int i = 0; i < m; i++) {
        int left = 0, right = len-1, total = 0;
        while(left <= right) {
            int mid = (left + right) / 2;
            // 找到第一个刚好大于等于 ages[i] 的位置
            // 用总人口数量减去这个位置的编号，就能得到大于该年龄的总数
            if(person[mid] >= ages[i]){
                right = mid - 1;
                total = len - mid;
            } else {
                left = mid + 1;
            }
        }
        cout<<total<<endl;
    }
}
```